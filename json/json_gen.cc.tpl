// This file was generated by json_gen.py

#include "{{headerpath}}"

{% if ctx.source_includes -%}
{% for filename in sorted(ctx.source_includes) -%}
#include "{{filename}}"
{% endfor %}
{% endif -%}

{%- if ctx.namespaces -%}
{% for ns in ctx.namespaces -%}
namespace {{ns}} {
{% endfor %}
{% endif -%}

{%- for qname, fields in sorted(ctx.specs) -%}
int parsefields_{{escapename(qname)}}(  //
    const json::stream::Registry& registry, const re2::StringPiece& key,
    json::LexerParser* stream, {{qname}}* out) {
  uint64_t keyid = json::runtime_hash(key);
  switch (keyid) {
    {% for field in fields -%}
    case json::hash("{{field}}"):
      registry.parse_value(stream, &out->{{field}});
      break;
    {% endfor %}
    default:
      json::sink_value(stream);
      return 1;
  }
  return 0;
}

int dumpfields_{{escapename(qname)}}(  //
    const {{qname}}& value, json::stream::Dumper* dumper) {
  int result = 0;
  {% for field in fields -%}
  result |= dumper->dump_field("{{field}}", value.{{field}});
  {% endfor -%}
  return result;
}
{%- if not loop.last %}

{% endif -%}
{%- endfor %}

// Register the type specific parsers/dumpers
int register_types(json::stream::Registry* registry) {
{%- for qname, fields in sorted(ctx.specs) %}
  registry->register_object(  //
      parsefields_{{escapename(qname)}},  //
      dumpfields_{{escapename(qname)}});
{%- endfor %}
return 0;
}

{%- if ctx.include_global_registration %}
static const int __dummy0 = register_types(json::stream::global_registry());
{%- endif %}
{% for ns in ctx.namespaces[::-1] %}
}  // namespace {{ns}}
{% endfor %}
